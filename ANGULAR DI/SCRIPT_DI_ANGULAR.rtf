{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fswiss\fcharset0 Arial-BoldMT;\f2\fswiss\fcharset0 Arial-ItalicMT;
\f3\fswiss\fcharset0 Arial-BoldItalicMT;\f4\fnil\fcharset128 HiraginoSans-W3;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red38\green38\blue38;\red255\green255\blue255;
\red238\green76\blue77;\red236\green239\blue237;\red176\green0\blue4;\red52\green52\blue52;\red0\green0\blue233;
\red239\green239\blue239;\red71\green71\blue71;\red253\green155\blue50;\red132\green0\blue2;\red24\green25\blue27;
\red29\green29\blue29;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c20000\c20000\c20000;\cssrgb\c100000\c100000\c100000;
\cssrgb\c95686\c39216\c37255;\cssrgb\c94118\c94902\c94510;\cssrgb\c75294\c0\c0;\cssrgb\c26667\c26667\c26667;\cssrgb\c0\c0\c93333;
\cssrgb\c94902\c94902\c94902;\cssrgb\c34902\c34902\c34902;\cssrgb\c100000\c67059\c25098;\cssrgb\c59608\c0\c0;\cssrgb\c12549\c12941\c14118;
\cssrgb\c14902\c14902\c14902;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww33400\viewh18300\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs48 \cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf2 \expnd0\expndtw0\kerning0
>> What is a dependency ?
\f0\b0  \cf3 \cb4 \
\pard\pardeftab720\sl276\partightenfactor0
\cf3 When module \cf5 \cb6 A\cf3 \cb4  in an application needs module \cf5 \cb6 B\cf3 \cb4  to run, then module \cf5 \cb6 B\cf3 \cb4  is a 
\f2\i dependency
\f0\i0  of module \cf5 \cb6 A\cf3 \cb4 .\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf3 \cb4 \
\'97\'97\'97\
\pard\pardeftab720\partightenfactor0

\f1\b \cf3 >> The problem with dependencies
\f0\b0 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\sl405\partightenfactor0

\f1\b \cf3 \cb4 Here we see that the Engine i
\f0\b0 s a 
\f2\i dependency
\f0\i0  of 
\f1\b Car
\f0\b0  !\cf2 \cb1 \
\

\f1\b \cf3 \cb4 Inflexible
\f0\b0 \cf2 \cb1 \
\cf3 \cb4 Hard to re-use. It hardcodes the\'a0 \cf5 \cb6 Engine\cf3 \cb4  \cf2 \cb1 \
\cf3 \cb4 How would you use this class if you wanted to use or Test another Engine provider?\cf2 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 Violates Single responsibility\'a0 \uc0\u8594  
\f1\b Car is here responsible for engine creation\
\'97\'97\'97\
\
>> Solution\
\
\pard\pardeftab720\sl276\partightenfactor0

\f0\b0 \cf3 \cb4 Previously the \cf5 \cb6 Car\cf3 \cb4  constructor was responsible for creating an 
\f2\i instance
\f0\i0  of its dependency the \cf5 \cb6 Engine\cf3 \cb4 .\cf2 \cb1 \
\cf3 \cb4 Now 
\f3\i\b something else
\f1\i0  is responsible
\f0\b0  for creating the 
\f2\i instance
\f0\i0  of \cf5 \cb6 Engine\cf3 \cb4  and then passing it into the \cf5 \cb6 Car\cf3 \cb4  via its constructor.\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\'97\'97\'97\
\
>>>  IOC ?\
\pard\pardeftab720\sl276\partightenfactor0
\cf3 \cb4 This idea of moving the responsibility of creating 
\f1\b concrete instances of dependencies
\f0\b0  \ul to something else \ulnone is called 
\f2\i Inversion of Control
\f0\i0 , or 
\f2\i IoC
\f0\i0 .\cf2 \cb1 \
\cf3 \cb4 The specific design pattern for implementing IoC above is called 
\f2\i Dependency Injection
\f0\i0 \cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\'97\'97\
\pard\pardeftab720\partightenfactor0

\f1\b \cf7 >>What is DI?
\f0\b0 \cf2  \
\pard\pardeftab720\partightenfactor0
\cf2 \cb4 Dependency Injection is a software design in which components are given their dependencies instead of hard coding them within the component. \cb1 \
\
\
\'97\
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf2 >> \cf8 Tree-shaking
\f0\b0 \cf2 \
\pard\pardeftab720\sl276\partightenfactor0
\cf8 Tree-shaking,: \cf2 \cb4 \'a0remove the service from the final bundle if the app does not use it\'a0 \uc0\u8594  smaller bundle sizes\cb1 \
\
>> 
\f1\b injector hierarchies
\f0\b0  \
\pard\pardeftab720\partightenfactor0
\cf2 \cb4 Angular Creates two injector trees when the app starts:\cb1 \
\
\cb4 Module Injector tree is for Modules (@NgModule)\cb1 \
\
\cb4 Element Injector tree is for DOM Elements like Components & Directives\cb1 \
\
Purpose hierarchies?\'a0 Scope/AVAILABILTY of injected services 
\f4 \'81\'cb
\f0  where can we use it in the application ?\'a0 \'96 Application wide or only at the scope of the component?\
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 Where you configure your services, will decide the service scope, service lifetime & bundle size.\
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \
\
\'97\'97\
\pard\pardeftab720\sl276\partightenfactor0

\f1\b \cf8 >>Module Injector hierarchy
\f0\b0 \cf2 \
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \cb4 We register the Module level services in two ways\cb1 \
1.\cb4 Using The Providers Metadata of the @{\field{\*\fldinst{HYPERLINK "https://www.tektutorialshub.com/angular/angular-modules/"}}{\fldrslt \cf9 \ul \ulc9 NgModule()}}\cb1 \
2.\cb4 Using the {\field{\*\fldinst{HYPERLINK "https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/"}}{\fldrslt \cf9 \ul \ulc9 @Injectable()}} Decorator with \cb10 providedIn : root \cb4 in the service itself\cb1 \
\
\pard\pardeftab720\sl276\partightenfactor0

\f1\b \cf8 Element Injector hierarchy
\f0\b0 \cf2 \

\f1\b \cf8 We register the services 
\f0\b0 in the 
\f1\b providers property
\f0\b0  on @{\field{\*\fldinst{HYPERLINK "https://angular.io/api/core/Directive"}}{\fldrslt \cf9 \ul \ulc9 Directive}}() or @{\field{\*\fldinst{HYPERLINK "https://angular.io/api/core/Component"}}{\fldrslt \cf9 \ul \ulc9 Component}}().\cf2 \
\
\'97\'97\
\
>> 
\f1\b \cf8 Root injector -
\f0\b0 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb4 Both configs will make the Services as SINGLETON available to the entire application. \cb1 \
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \
\pard\pardeftab720\sl276\partightenfactor0

\f1\b \cf2 \ul \ulc2 Platform Injector
\f0\b0 \ulnone \
\pard\pardeftab720\sl276\partightenfactor0

\f2\i \cf2 \cb4 A special singleton platform injector shared by all applications on the page
\f0\i0 .\cb1 \
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \cb4 This is a useful injector if you have multiple Angular Apps running on a single page.\cb1 \
\cb4 Example: Multiple Angular Elements, where they can share a single instance of service between them.\cb1 \
\
\pard\pardeftab720\sl276\partightenfactor0

\f1\b \cf8 \ul \ulc8 Child injector
\f0\b0 \cf2 \ulnone \
\pard\pardeftab720\partightenfactor0
\cf8 This Injector instance is created for every 
\f1\b Lazy-loaded
\f0\b0  module\cf2 \
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \cb4 Angular creates them only when it loads them via ROUTINGS.\cb1 \
\cb4 \'a0They are configured with the providers from the following locations.\cb1 \
1.\cb4 Providers metadata of \cb10 @NgModule\cb4  of the Module 
\f1\b being Lazy loaded
\f0\b0 \cb1 \
2.\cb4 All the services which have \cb10 providedIn\cb4  metadata with value
\f1\b  \cb10 any
\f0\b0 \cb4  in their {\field{\*\fldinst{HYPERLINK "https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/"}}{\fldrslt \cf9 \ul \ulc9 @Injectable()}} decorator\cb1 \
\
\'97\
\
>> 
\f1\b \cf7 Eagerly loaded Modules
\f0\b0  \cf11 versus 
\f1\b \cf12 Lazy loaded Modules
\f0\b0 \cf2 \
\
\
 By default, NgModules are eagerly loaded, which means:\'a0 that as soon as the application loads,\'a0 all the non-Lazy NgModules are also loaded.\
\pard\pardeftab720\partightenfactor0
\cf2 \
For large applications with lots of ROUTES, consider lazy loading\'97a design pattern that loads NgModules when needed !!!\
\'a0Lazy loading helps keep initial bundle sizes smaller, which in turn helps decrease load times.\
\
\'97\'97\
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf2 >>> How to Lazy load a module in Angular?
\f0\b0  \
\uc0\u9679 To lazy load Angular modules, use\'a0
\f1\b loadChildren (instead of component )
\f0\b0 \'a0in your RoutingModule\
\
\'97\'97\
\
\pard\pardeftab720\li249\sl276\partightenfactor0

\f1\b \cf7 >>> Availability or Scope of provided Services\
\
>>>ANY 
\f0\b0 \cf2 diagram
\f1\b \cf7 \
\
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf2 \uc0\u9679 With provideIn Any, all eagerly loaded modules share the same singleton instance. \
However , lazy loaded modules each get their 
\f1\b own unique instance
\f0\b0 , as shown in the following diagram\
\pard\pardeftab720\li249\sl276\partightenfactor0

\f1\b \cf7 \
\'97\'97\
\
\pard\pardeftab720\sl276\partightenfactor0

\f0\b0 \cf2 >>>Element Injector Hierarchy\
\pard\pardeftab720\sl276\partightenfactor0

\f1\b \cf7 \
\pard\pardeftab720\sl276\partightenfactor0

\f0\b0 \cf2 Angular creates the Element Injector tree for the services to be provided at the element level like Components & Directives.\
\
\pard\pardeftab720\li960\sl276\sa400\partightenfactor0
\cf8 You configure it in the 
\f1\b providers property
\f0\b0  on @{\field{\*\fldinst{HYPERLINK "https://angular.io/api/core/Directive"}}{\fldrslt \cf9 \ul \ulc9 Directive}}() or @{\field{\*\fldinst{HYPERLINK "https://angular.io/api/core/Component"}}{\fldrslt \cf9 \ul \ulc9 Component}}().\cf2 \
\pard\pardeftab720\li249\sl144\slmult1\partightenfactor0

\f1\b \cf7 \'97\'97\
\
Dependency Resolution\
\
\pard\pardeftab720\li326\partightenfactor0

\f0\b0 \cf2 Angular resolves the dependency in two phases:\
\pard\pardeftab720\partightenfactor0
\cf2 \uc0\u9679 First, resolve it using the Element Injector and its parents\
\uc0\u9679 If found then the 
\f1\b injector
\f0\b0  injects it into the component\'a0\
\uc0\u9679 If not found in the Element Injector, then resolve it against the Module Injector and its parents.\
\pard\pardeftab720\li249\sl144\slmult1\partightenfactor0

\f1\b \cf7 \
\
>> \cf8 Inject EngineService instance from RootCarComponent Injector, into grand-child Component
\f0\b0 \cf2 \

\f1\b \cf7 \
\
I\
\pard\pardeftab720\li249\sl276\partightenfactor0

\f0\b0 \cf2 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf2 >>> If not found in element tree\
\pard\pardeftab720\sa266\partightenfactor0
\cf8 Could not resolve dependency\'a0 in\'a0 Element Injector tree
\f0\b0 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 And delegate resolving of our dependency to our module injector tree.\
\
\'97\'97\
\
\pard\pardeftab720\sl276\sa320\partightenfactor0

\f1\b \cf13 >> Resolution Modifiers
\f0\b0 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf14 \cb4 @Self 
\f1\b tells
\f0\b0  
\f1\b Angular that it should only look within the local injector on the current element. If there is no provider found throw an error.
\f0\b0 \cf2 \cb1 \
\
\
@SkipSelf 
\f1\b tells Angular that it should skip local injector and start traversing the injector tree from the parent injector.
\f0\b0 \
\
@Optional 
\f1\b tells Angular that it should not throw the error if there is no provider and just returns NULL
\f0\b0 \
\
@Host tells Angular that it should resolve dependencies in] the scope of the current component view. It is applicable mostly for directives!\
\
\'97\
\pard\pardeftab720\partightenfactor0

\f1\b \cf13 >>> Dependency Providers
\f0\b0 \cf2 \
\
\pard\pardeftab720\sl276\partightenfactor0
\cf15 \cb4 We configure injectors with providers, Angular then uses these injectors to resolve dependencies using tokens and injecting them into constructors.\cf2 \cb1 \
\
\cf15 \cb4 There are 4 types of providers: \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl276\partightenfactor0
\ls1\ilvl0\cf15 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
a class provider, \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
a value provider, \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
a factory function provider and\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
an alias provider (useExisting).\
\pard\tx566\pardeftab720\sl276\partightenfactor0
\cf2 \cb1 \
\'97\'97\
\
>> Concept\
\pard\pardeftab720\partightenfactor0

\f1\b \cf3 \cb4 The Providers consist of these 4 concepts:
\f0\b0 \cf2 \cb1 \
\

\f1\b \cf3 \cb4 Token
\f0\b0 \cf2 \cb1 \
\cf3 \cb4 This uniquely identifies something that we want injected. The KEY in our MAP !!!.\cf2 \cb1 \

\f1\b \cf3 \cb4 Dependency
\f0\b0 \cf2 \cb1 \
\cf3 \cb4 The actual code we want injected.\cf2 \cb1 \

\f1\b \cf3 \cb4 Provider
\f0\b0 \cf2 \cb1 \
\cf3 \cb4 This is a map between a 
\f2\i token
\f0\i0  and a list of 
\f2\i dependencies
\f0\i0 .\cf2 \cb1 \

\f1\b \cf3 \cb4 Injector
\f0\b0 \cf2 \cb1 \
\cf3 \cb4 This is a function which when passed a 
\f2\i token
\f0\i0  returns a 
\f2\i dependency
\f0\i0  (or list of dependencies).\cf2 \cb1 \
\pard\tx566\pardeftab720\sl276\partightenfactor0
\cf2 \
\'97\
\pard\pardeftab720\partightenfactor0
\cf2 \
Injection Token\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb4 The Angular provides {\field{\*\fldinst{HYPERLINK "https://www.tektutorialshub.com/angular/injection-token-in-angular/"}}{\fldrslt \cf9 \cb10 \ul \ulc9 InjectionToken}} class so as to ensure that the 
\f1\b Unique tokens
\f0\b0  are created.\cb1 \
\
\
\
\'97\'97\
\
>>> useFactory:\
\
\pard\pardeftab720\partightenfactor0
\cf14 \cb4 Use useFactory 
\f1\b when the injection value should be computed at runtime
\f0\b0 , \cf2 \cb1 \
\
\pard\pardeftab720\li76\ri456\sl393\qj\partightenfactor0

\f1\b \cf2 \cb4 provide
\f0\b0 : configure the token that will be used in dependency injection.\cb1 \
\cb4 \

\f1\b useFactory
\f0\b0 : configures a factory method that can return objects, string, array, etc.\cb1 \
\cb4 \

\f1\b deps
\f0\b0 : configures the token that the injector will use to provide the dependency injection required by the factory method.\cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\
\pard\pardeftab720\sl276\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\
\
\
}